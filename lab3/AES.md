# AES

AES (англ. Advanced Encryption Standard; также Rijndael, [rɛindaːl] — рейндал) — симметричный алгоритм блочного шифрования (размер блока 128 бит, ключ 128/192/256 бит), принятый в качестве стандарта шифрования правительством США по результатам конкурса AES. Этот алгоритм хорошо проанализирован и сейчас широко используется, как это было с его предшественником DES. Национальный институт стандартов и технологий США (англ. National Institute of Standards and Technology, NIST) опубликовал спецификацию AES 26 ноября 2001 года после пятилетнего периода, в ходе которого были созданы и оценены 15 кандидатур. 26 мая 2002 года AES был объявлен стандартом шифрования. По состоянию на 2009 год AES является одним из самых распространённых алгоритмов симметричного шифрования. Поддержка ускорения AES была введена фирмой Intel в семейство процессоров x86 начиная с Arrandale[англ.] в 2010 году, а затем на процессорах Sandy Bridge; фирмой AMD — в Bulldozer с 2011 года.

В начале зашифровывания input копируется в массив State по правилу $ \mathrm {state} [r,c]=\mathrm {input} [r+4c]$, для 
$ 0\leq r<4$ и $ 0\leq c<Nb $. 

После этого к State применяется процедура AddRoundKey(), и затем State проходит через процедуру трансформации (раунд) 10, 12, или 14 раз (в зависимости от длины ключа), при этом надо учесть, что последний раунд несколько отличается от предыдущих. В итоге, после завершения последнего раунда трансформации, State копируется в output по правилу 
$ {output} [r+4c]=\mathrm {state} [r,c] $, для $ 0\leq r<4 $ и $ 0\leq c<Nb $.

## Процедура SubBytes() 

обрабатывает каждый байт состояния, независимо производя нелинейную замену байтов, используя таблицу замен (S-box). Такая операция обеспечивает нелинейность алгоритма шифрования. Построение S-box состоит из двух шагов. Во-первых, производится взятие обратного числа в поле Галуа 
$ GF\left({2^{8}}\right)$. 

Для всех операций в этом поле используется неприводимый полином $ z^{8}+z^{4}+z^{3}+z+1 $. 

Во-вторых, к каждому байту b, из которых состоит S-box, применяется следующая операция:
$ b'_{i}=b_{i}\oplus b_{\left({i+4}\right){\bmod {8}}}\oplus b_{\left({i+5}\right){\bmod {8}}}\oplus b_{\left({i+6}\right){\bmod {8}}}\oplus b_{\left({i+7}\right){\bmod {8}}}\oplus c_{i} $
где 
$ 0\leq i<8$, и где $ b_{i}$ есть i-ый бит b, а $ c_{i}$ — i-ый бит константы 
$ c=63_{16}=99_{10}=01100011_{2}$ .

![](img/ae)

## ShiftRows 

работает со строками State. При этой трансформации строки состояния циклически сдвигаются на `r` байт по горизонтали в зависимости от номера строки. Для нулевой строки `r = 0`, для первой строки `r = 1` и т. д. Таким образом, каждая колонка выходного состояния после применения процедуры ShiftRows состоит из байтов из каждой колонки начального состояния. Для алгоритма Rijndael паттерн смещения строк для 128- и 192-битных строк одинаков. Однако для блока размером 256 бит отличается от предыдущих тем, что 2-е, 3-и и 4-е строки смещаются на 1, 3 и 4 байта соответственно. Это замечание не относится к AES, так как он использует алгоритм Rijndael только с 128-битными блоками, независимо от размера ключа.

![](img/aes-2.svg)

## MixColumns

В процедуре MixColumns четыре байта каждой колонки State смешиваются, используя для этого обратимую линейную трансформацию. MixColumns обрабатывает состояния по колонкам, трактуя каждую из них как полином третьей степени. Над этими полиномами производится умножение в $GF(2^{8})$ по модулю $x^{4}+1$ на фиксированный многочлен $c(x)=3x^{3}+x^{2}+x+2$. Вместе с ShiftRows MixColumns вносит диффузию в шифр.

![](img/aes-3.svg)

## AddRoundKey

В процедуре AddRoundKey RoundKey каждого раунда объединяется со State. Для каждого раунда Roundkey получается из CipherKey c помощью процедуры KeyExpansion; каждый RoundKey такого же размера, что и State. Процедура производит побитовый XOR каждого байта State с каждым байтом RoundKey.

![](img/aes-4.svg)

## Алгоритм обработки ключа

Алгоритм обработки ключа состоит из двух процедур:

* Алгоритм генерации раундовых ключей (алгоритм расширения ключа)
* Алгоритм выбора раундового ключа (ключа итерации)

### Алгоритм генерации раундовых ключей

Алгоритм AES, используя процедуру KeyExpansion() и подавая в неё Cipher Key, `K`, получает ключи для всех раундов. Всего получается $Nb*(Nr + 1)$ слов: изначально для алгоритма требуется набор из `Nb` слов, и каждому из `Nr` раундов требуется Nb ключевых набора данных. Полученный массив ключей для раундов обозначается как $w\left[i\right]$, $ 0\leq i<Nb*(Nr+1) $.

### Алгоритм выбора раундового ключа
На каждой итерации $i$ раундовый ключ для операции AddRoundKey выбирается из массива $ w\left[i\right]$,начиная с элемента $w\left[Nb*i\right]$ до $w\left[Nb*\left(i+1\right)\right]$.